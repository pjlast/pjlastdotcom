// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.819
package main

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func styleSheet() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<link rel=\"stylesheet\" href=\"/css/prism.css\" type=\"text/css\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func hiddenSimplicity() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var2 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var2 == nil {
			templ_7745c5c3_Var2 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var3 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<nav><h2>Petri-Johan Last</h2><ul role=\"list\"><li><a href=\"/\">About</a></li><li><a href=\"/writing\">Writing</a></li><li><a href=\"/work-history\">Work history</a></li></ul></nav><main><h1>Hidden simplicity</h1><p><time datetime=\"2024-11-25\">25 November 2024</time></p><p>I recently tried to simplify a section of our auth code at work. Specifically some middleware that handles the routes of various OAuth providers. It's the kind of free range, organic, grass fed, hormone free, natural code you'll only find in production critical work software.</p><p>Code like this comes from many years of minor edits by many different people working in many different contexts. This specific file has been edited by 23 people over the span of 6 years, for reasons like feature additions, files being moved around, bug fixes, customer-specific requests, adding tracing, etc. You know. Work stuff.</p><p>Now, the code itself isn't actually particularly complex, but the context under which you arrive at the code certainly can be. There's going to be a whole lot of code, and you don't have to try and read and understand all of it, but I think it's important to have a sense of all the pieces involved here. Let's start with the function signature:</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var4 string
			templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(`func NewMiddleware(
	db database.DB,
	serviceType string,
	authPrefix string,
	isAPIHandler bool,
	next http.Handler,
) http.Handler`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 49, Col: 15}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "</code></pre><p>Depending on whether or not this is your first rodeo in the auth code, you might already have some questions. \"What is a service type?\" \"Auth prefix?\" \"Alright, so it differentiates between API requests and other requests?\".</p><p>If we do a find-references on this function, we'll have some of our questions answered. The function is called by a number of different auth provider implementations, and all the call-sites follow the exact same pattern. Here's where the function is called in the GitHub OAuth middleware:</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var5 string
			templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(`const authPrefix = auth.AuthURLPrefix + "/github"

func Middleware(db database.DB) *auth.Middleware {
	return &amp;auth.Middleware{
		API: func(next http.Handler) http.Handler {
			return oauth.NewMiddleware(db, extsvc.TypeGitHub,
				authPrefix, true, next)
		},
		App: func(next http.Handler) http.Handler {
			return oauth.NewMiddleware(db, extsvc.TypeGitHub,
				authPrefix, false, next)
		},
	}
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 80, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "</code></pre><p>So <code class=\"language-go\">authPrefix</code> is some <code class=\"language-go\">auth.AuthURLPrefix</code> followed by the name of the OAuth provider. A quick go-to-def on <code class=\"language-go\">auth.AuthURLPrefix</code> reveals that it's simply the string <code class=\"language-go\">\"/.auth\"</code>.</p><p>We also see that <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var6 string
			templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(`serviceType`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 91, Col: 62}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "</code> is a variable called <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var7 string
			templ_7745c5c3_Var7, templ_7745c5c3_Err = templ.JoinStringErrs(`extsvc.TypeGitHub`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 92, Col: 67}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var7))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</code>, and following the trail shows us the value is simply <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var8 string
			templ_7745c5c3_Var8, templ_7745c5c3_Err = templ.JoinStringErrs(`"github"`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 94, Col: 42}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var8))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "</code>. This pattern holds true for all OAuth providers.</p><p>Finally, we see that each OAuth provider's middleware has two functions: one for API middleware, and one for App middleware (App simply meaning browser UI). The <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var9 string
			templ_7745c5c3_Var9, templ_7745c5c3_Err = templ.JoinStringErrs(`isAPIHandler`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 100, Col: 63}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var9))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "</code> parameter is set appropriately depending on the handler.</p><p>Each OAuth provider's <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var10 string
			templ_7745c5c3_Var10, templ_7745c5c3_Err = templ.JoinStringErrs(`func Middleware()`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 105, Col: 51}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var10))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, "</code> is called during startup when the middlewares are registered:</p><pre><code class=\"language-go\">auth.RegisterMiddlewares( authutil.ConnectOrSignOutMiddleware(db), openidconnect.Middleware(logger, db), sourcegraphoperator.Middleware(db), saml.Middleware(db), httpheader.Middleware(logger, db), githuboauth.Middleware(db), gitlaboauth.Middleware(db), bitbucketcloudoauth.Middleware(db), bitbucketserveroauth.Middleware(db), azureoauth.Middleware(db), )</code></pre><p>Okay cool, so let's get to the rest of the function. Again, you don't have to try and read and understand the entire thing, I'll get to the relevant bits, but it's worth understanding that it's quite a chunk of text, and at this point you're already holding quite a bit of context in your head.</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var11 string
			templ_7745c5c3_Var11, templ_7745c5c3_Err = templ.JoinStringErrs(`func NewMiddleware(
	db database.DB,
	serviceType string,
	authPrefix string,
	isAPIHandler bool,
	next http.Handler,
) http.Handler {
	oauthFlowHandler := http.StripPrefix(
		authPrefix,
		newOAuthFlowHandler(serviceType),
	)
	traceFamily := fmt.Sprintf("oauth.%s", serviceType)

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// This span should be manually finished before delegating to the next
		// handler or redirecting.
		span, ctx := trace.New(r.Context(), traceFamily+".middleware")
		span.SetAttributes(attribute.Bool("isAPIHandler", isAPIHandler))

		// Delegate to the auth flow handler
		if !isAPIHandler &amp;&amp; strings.HasPrefix(r.URL.Path, authPrefix+"/") {
			span.AddEvent("delegate to auth flow handler")
			r = withOAuthExternalClient(r)
			span.End()
			oauthFlowHandler.ServeHTTP(w, r)
			return
		}

		// If the actor is authenticated and not performing an OAuth flow,
		// then proceed to next.
		if actor.FromContext(ctx).IsAuthenticated() {
			span.AddEvent("authenticated, proceeding to next")
			span.End()
			next.ServeHTTP(w, r)
			return
		}

		// If there is only one auth provider configured, the single auth
		// provider is a OAuth instance, it's an app request, the sign-out
		// cookie is not present, and access requests are disabled, redirect to
		// sign-in immediately.
		//
		// For sign-out requests (sign-out cookie is  present), the user will
		// be redirected to the SG login page.
		// Note: For instances that are conf.AuthPublic(), we don't redirect
		// to sign-in automatically, as that would lock out unauthenticated
		// access.
		pc := getExactlyOneOAuthProvider(
			!r.URL.Query().Has("sourcegraph-operator"),
		)
		if !conf.AuthPublic() &amp;&amp; pc != nil &amp;&amp; !isAPIHandler &amp;&amp;
			pc.AuthPrefix == authPrefix &amp;&amp; !session.HasSignOutCookie(r) &amp;&amp;
			isHuman(r) &amp;&amp; !conf.IsAccessRequestEnabled() {
			span.AddEvent("redirect to signin")
			v := make(url.Values)
			v.Set("redirect", auth.SafeRedirectURL(r.URL.String()))
			v.Set("pc", pc.ConfigID().ID)
			span.End()
			http.Redirect(
				w,
				r,
				authPrefix+"/login?"+v.Encode(),
				http.StatusFound,
			)

			return
		}
		span.AddEvent("proceeding to next")
		span.End()
		next.ServeHTTP(w, r)
	})
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 204, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var11))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "</code></pre><p>Alright, first thing's first: the <code class=\"language-go\">db database.DB</code> parameter is unused. We can just delete it. Also, something we saw earlier: <code class=\"language-go\">authPrefix</code> is simply <code class=\"language-go\">\"/.auth/\" + serviceType</code>. So that's another parameter gone. But we can do better. Go 1.22 improved the <code class=\"language-go\">http</code> package and added support for wildcard patterns and path parameters. Prior to 1.22, if you wanted some dynamic path parameters, you either had to do some shenanigans, or you had to use a third-party library. This function opted for the shenanigans. But, we've had 1.22 for a while now, and we now know that all of the OAuth providers follow the same pattern. So my plan was to get rid of the <code class=\"language-go\">authPrefix</code> and <code class=\"language-go\">serviceType</code> parameters altogether, and have a HTTP handler for the path <code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var12 string
			templ_7745c5c3_Var12, templ_7745c5c3_Err = templ.JoinStringErrs(`"/.auth/{serviceType}"`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 223, Col: 56}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var12))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "</code>. So with the first three parameters of the function deemed obsolete, that leaves <code class=\"language-go\">isAPIHandler</code> and <code class=\"language-go\">next</code>.</p><p>At this point I wondered whether or not having a function with a boolean flag is really necessary, so I made 2 copies of the function instead: one where <code class=\"language-go\">isAPIHandler = true</code> (<code class=\"language-go\">func NewAPIMiddleware()</code>), and one where <code class=\"language-go\">isAPIHandler = false</code> (<code class=\"language-go\">func NewAppMiddleware()</code>). There are two checks in the code where this is relevant:</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var13 string
			templ_7745c5c3_Var13, templ_7745c5c3_Err = templ.JoinStringErrs(`if !isAPIHandler &amp;&amp; strings.HasPrefix(r.URL.Path, authPrefix+"/") {`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 238, Col: 113}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var13))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 12, "</code></pre><p>and this monstrosity:</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var14 string
			templ_7745c5c3_Var14, templ_7745c5c3_Err = templ.JoinStringErrs(`if !conf.AuthPublic() &amp;&amp; pc != nil &amp;&amp;
	!isAPIHandler &amp;&amp; pc.AuthPrefix == authPrefix &amp;&amp;
	!session.HasSignOutCookie(r) &amp;&amp; isHuman(r) &amp;&amp;
	!conf.IsAccessRequestEnabled() {`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 245, Col: 34}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var14))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 13, "</code></pre><p>But both of these evaluate to <code class=\"language-go\">false</code> when <code class=\"language-go\">isAPIHandler = true</code>. So, we can just take them out.</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var15 string
			templ_7745c5c3_Var15, templ_7745c5c3_Err = templ.JoinStringErrs(`func NewAPIMiddleware(
	serviceType,
	authPrefix string,
	next http.Handler,
) http.Handler {
	oauthFlowHandler := http.StripPrefix(authPrefix,
		newOAuthFlowHandler(serviceType))
	traceFamily := fmt.Sprintf("oauth.%s", serviceType)

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		span, ctx := trace.New(r.Context(), traceFamily+".middleware")
		span.SetAttributes(attribute.Bool("isAPIHandler", true))

		if actor.FromContext(ctx).IsAuthenticated() {
			span.AddEvent("authenticated, proceeding to next")
			span.End()
			next.ServeHTTP(w, r)
			return
		}

		span.AddEvent("proceeding to next")
		span.End()
		next.ServeHTTP(w, r)
	})
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 280, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var15))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 14, "</code></pre><p>Alright, big chunk of the function is gone now. This leaves us with one last condition: if the user is authenticated, serve the next middleware, otherwise... serve the next middleware? Cool, so we can drop that check as well, I guess?</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var16 string
			templ_7745c5c3_Var16, templ_7745c5c3_Err = templ.JoinStringErrs(`func NewAPIMiddleware(
	serviceType,
	authPrefix string,
	next http.Handler,
) http.Handler {
	oauthFlowHandler := http.StripPrefix(authPrefix,
		newOAuthFlowHandler(serviceType))
	traceFamily := fmt.Sprintf("oauth.%s", serviceType)

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		span, ctx := trace.New(r.Context(), traceFamily+".middleware")
		span.SetAttributes(attribute.Bool("isAPIHandler", true))

		span.AddEvent("proceeding to next")
		span.End()
		next.ServeHTTP(w, r)
	})
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 308, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var16))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 15, "</code></pre><p>So now we have a middleware that, uhm, calls the next middleware?</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var17 string
			templ_7745c5c3_Var17, templ_7745c5c3_Err = templ.JoinStringErrs(`func NewAPIMiddleware(next http.Handler) http.Handler {
	return next
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 316, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var17))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 16, "</code></pre><p>So I just deleted the function altogether:</p><pre><code class=\"language-go\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var18 string
			templ_7745c5c3_Var18, templ_7745c5c3_Err = templ.JoinStringErrs(`func Middleware(logger log.Logger) *auth.Middleware {
	return &auth.Middleware{
		API: func(next http.Handler) http.Handler {
			return next
		},
		App: func(next http.Handler) http.Handler {
			return newAppMiddleware(logger, next)
		},
	}
}`)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `hidden_simplicity.templ`, Line: 331, Col: 2}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var18))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 17, "</code></pre><p>So, uh, yeah, hope you didn't spend too much time gathering all that context while debugging that API bug, because it turns out the function does <em>absolutely nothing</em>. In retrospect this makes perfect sense. This function is supposed to facilitate an OAuth login flow, which is only possible through the UI. There's no auth flow for API calls, so it makes sense that it's just a fallthrough. But if you ever came across this code in the wild, would your initial thought be \"hmm, let's first make sure this function <em>does anything</em>\"?</p><p>And now I can't help but wonder how much time has been lost by the 20-something people that dabbled in this code before me.</p></main><script src=\"/js/prism.js\"></script>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = layout("pjlast - Hidden simplicity", styleSheet()).Render(templ.WithChildren(ctx, templ_7745c5c3_Var3), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
